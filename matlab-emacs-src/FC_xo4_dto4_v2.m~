function Err=FC_xo4_dto4_v2(raff,T,FC)
%param simu => 1 = simulation // 0 = max val propres
%FC=1 => Flux centrés
%FC=0 => Symetrique
%---------------------------------------------------
close all
%==================================================
% Ajouts des repertoires:  fctions de bases etc ...
%==================================================
addpath /home/jdiaz1/matlab/Schema_P3/fonctions_bases_o4
addpath /home/jdiaz1/matlab/fonctions_maths


%------------------------------------------------------------
% Schéma DG Flux Centré avec nouvelle technique dintegration 
% (tps puis espace)
%------------------------------------------------------------

%===============================
nslow=1;        %Rapport zone transition
%raff=1;         %Raffinement dx dx=dx/raff
L=2;            %Zone Grossiere
L1=2;           %Zone Fine
mul=1;          %%%%%%%%%%%
dec=2;          %%%%%%%%%%%
dec2=0;         %%%%%%%%%%%
dx=0.2/raff;    %Pas despace
n=floor(L/dx);  %nb elem zone grossiere
%T=60;           %Temps de lexperience
x0=3;
r0=4;
PtGL=[0 (5-sqrt(5))/10 (5+sqrt(5))/10 1];  %%Points de Gauss Lobatto
WGL=[1 5 5 1]/12;
x(1)=0;
c(1)=1;         %c=vitesse de 1
c2(1)=c(1)^2;   %c² 
smooth=0;
n1=floor(L1/dx*nslow); %nb elem zone fine

%==============================
%   Definition du maillage
%==============================
%i=elem
%Gros
for i=1:n
  c(i)=1;    
  c2(i)=c(i)^2;
  x(i+1)=x(i)+dx;
end

%Fin
for i=n+1:n+n1
  c(i)=1;    
  c2(i)=c(i)^2;
  x(i+1)=x(i)+dx/nslow;
end

%Gros
for i=n+n1+1:2*n+n1
  c(i)=1;    
  c2(i)=c(i)^2;
  x(i+1)=x(i)+dx;
end

le=x(end);   %longueur du domaine x(final)=6.0

%%==================================================================
%% Definition de la matrice de projection P (fast) et 1-P (slow)
%%===================================================================

%%%%%%%%%%%%%%%%%%%
%elements Grossiers
%%%%%%%%%%%%%%%%%%%
slow=[1:4*(n-dec)-dec2 4*(n+n1+dec)+1+dec2:4*(2*n+n1) ];

%%%%%%%%%%%%%
%elements Fin
%%%%%%%%%%%%%
fast=[4*(n-dec)+1-dec2: 4*(n+n1+dec)+dec2];

n=2*n+n1+1; %nb_points
P=sparse(4*n-4,4*n-4);  %4*n-4=nb_glo_fonctions de formes ou 4*nb_elem=4*(2n+n1)

for i=fast
  P(i,i)=1;
end

PP=eye(4*n-4,4*n-4)-P;   %I-P pour zone grossiere && P pour zone fine

for i=1:n-1
  h(i)=x(i+1)-x(i);    %definition de la lgrs de chaque elem
end

  h(n)=h(1);  
  
  %Absice des fonctions des formes glob 
  %x(1)...x(5) =x(1) >> x(2)...x(6)=x(1)+h/3 >> x(3)...x(7)=x(1)+2*h/3 >>
  %x(4)...x(8)=x(2)
  
  X(1:4:4*(n-2)+2)=x(1:n-1);
  X(2:4:4*(n-2)+3)=x(1:n-1)+h(1:n-1)/3;
  X(3:4:4*(n-2)+4)=x(1:n-1)+2*h(1:n-1)/3;
  X(4:4:4*(n-2)+5)=x(2:n);
  
   
  for i=2:n-1
    hmin(i)=min(h(i),h(i-1));
    c2max(i)=max(c2(i),c2(i-1));
  end
  
  hmin(1)=min(h(1),h(n-1));
  hmin(n)=hmin(1);

  c2max(1)=max(c2(1),c2(n-1));
  c2max(n)=c2max(1);
  
  M=sparse(4*n-4,4*n-4);
  Minv=sparse(4*n-4,4*n-4);
  
  C=sparse(4*n-4,4*n-4);
  C2=sparse(4*n-4,4*n-4);
  
  A=sparse(4*n-4,4*n-4);
  A2=sparse(4*n-4,4*n-4);
  
  Aenerg=sparse(4*n-4,4*n-4);
 
  
  xx(1)=6.0037409897572858D-3;
  xx(2)=3.1363303799647048D-2;
  xx(3)=7.5896708294786392D-2;
  xx(4)=1.3779113431991498D-1;
  xx(5)=2.1451391369573058D-1;
  xx(6)=3.0292432646121832D-1;
  xx(7)=3.9940295300128274D-1;
  xx(8)=5.D-1;
  xx(9)=1-xx(7);
  xx(10)=1-xx(6);
  xx(11)=1-xx(5);
  xx(12)=1-xx(4);
  xx(13)=1-xx(3);
  xx(14)=1-xx(2);
  xx(15)=1-xx(1);
  
  %------------------------------------------------------
  % Calcul de la matrice de masse pour la maille unite
  % Integration Numérique Newton - matrice Symétrique
  %------------------------------------------------------
  m=Phi1(xx).*Phi1(xx);
  Mi(1,1)=Intgauss(m);
  m=Phi1(xx).*Phi2(xx);
  Mi(1,2)=Intgauss(m);
  Mi(2,1)=Mi(1,2);
  m=Phi1(xx).*Phi3(xx);
  Mi(1,3)=Intgauss(m);
  Mi(3,1)=Mi(1,3);
  m=Phi1(xx).*Phi4(xx);
  Mi(1,4)=Intgauss(m);
  Mi(4,1)=Mi(1,4);
    
  m=Phi2(xx).*Phi2(xx);
  Mi(2,2)=Intgauss(m);
  m=Phi2(xx).*Phi3(xx);
  Mi(2,3)=Intgauss(m);
  Mi(3,2)=Mi(2,3);
  m=Phi2(xx).*Phi4(xx);
  Mi(2,4)=Intgauss(m);
  Mi(4,2)=Mi(2,4);
    
  m=Phi3(xx).*Phi3(xx);
  Mi(3,3)=Intgauss(m);
  m=Phi3(xx).*Phi4(xx);
  Mi(3,4)=Intgauss(m);
  Mi(4,3)=Mi(3,4);
    
  m=Phi4(xx).*Phi4(xx);
  Mi(4,4)=Intgauss(m);
  %-----------------------
  
  %%==========================================================
  %%
  %% Calcul de la matrice de masse globale et de son inverse
  %%
  %%==========================================================
  for i=1:n-1
    M(4*i-3:4*i,4*i-3:4*i)=Mi*h(i);   %Remplissage des blocs diag M
  end
  
  Mi=Mi^(-1);        %matrice masse identite inverse M
  
  for i=1:n-1
    Minv(4*i-3:4*i,4*i-3:4*i)=Mi/h(i);
  end
    
  %%====================================================
  %%%
  %%% Calcul de la matrice de raideur :
  %%% Calcul du terme int(c2 u v') pour la maille unite
  %%% 1/ Pour la vitesse u=v & v=gamma
  %%% 2/ Pour la pression u=p & v=beta
  %%% 1 <=> 2 en 1D car div_1D=grad_1D
  %%====================================================
  
  %--Sum p_i phi_i grad psi_1 ....Sum p_i phi_i grad psi_4  
  m=Phi1(xx).*Derphi1(xx);
  Mi(1,1)=Intgauss(m);
  m=Phi2(xx).*Derphi1(xx);
  Mi(2,1)=Intgauss(m);
  m=Phi3(xx).*Derphi1(xx);
  Mi(3,1)=Intgauss(m);
  m=Phi4(xx).*Derphi1(xx);
  Mi(4,1)=Intgauss(m);
    
  m=Phi1(xx).*Derphi2(xx);
  Mi(1,2)=Intgauss(m);
  m=Phi2(xx).*Derphi2(xx);
  Mi(2,2)=Intgauss(m);
  m=Phi3(xx).*Derphi2(xx);
  Mi(3,2)=Intgauss(m);
  m=Phi4(xx).*Derphi2(xx);
  Mi(4,2)=Intgauss(m);
  
  m=Phi1(xx).*Derphi3(xx);
  Mi(1,3)=Intgauss(m);
  m=Phi2(xx).*Derphi3(xx);
  Mi(2,3)=Intgauss(m);
  m=Phi3(xx).*Derphi3(xx);
  Mi(3,3)=Intgauss(m);
  m=Phi4(xx).*Derphi3(xx);
  Mi(4,3)=Intgauss(m);
  
  m=Phi1(xx).*Derphi4(xx);
  Mi(1,4)=Intgauss(m);
  m=Phi2(xx).*Derphi4(xx);
  Mi(2,4)=Intgauss(m);
  m=Phi3(xx).*Derphi4(xx);
  Mi(3,4)=Intgauss(m);
  m=Phi4(xx).*Derphi4(xx);
  Mi(4,4)=Intgauss(m);
  
  % Computation du terme int(c2 u v') global
  % Remarque :  ici on a plus le signe moins de par les integrations
  % par parties que nous donne au final un plus.
  %------------------------------------------------------------------
  for i=1:n-1
    C(4*i-3:4*i,4*i-3:4*i)=Mi; %%J^(-1)=1/(x2-x1)=1/h 
  end
  %==============================%
  
 
  %%==============================
  %%% Calcul de la condition CFL
  %%==============================
  dt=2.05*(0.0682*dx)/2
  %return
  
  %/!\------------------------------------------------------
  %%VERIFIER LES SIGNES POUR LES +-0.5 suivant le signe de
  %lintergrale mais signe pour normal ok !
    
  %---------------------------------------------------------------------------------
  % Condition Periodique
  %----------------------
  alpha_1=0.01
  Cper1=C;
  %=> premier saut phiIphiJ
  %------------------------
  i=1;
  %periodique
  Cper1(1,1)=Cper1(1,1)+0.5+alpha_1;
  Cper1(1,4*n-4)=Cper1(1,4*n-4)-0.5+alpha_1;
  %endperiodic
  
  Cper1(4,4)=Cper1(4,4)-0.5+alpha_1;
  Cper1(4,5)=Cper1(4,5)+0.5+alpha_1;
  for i=2:n-2
    Cper1(4*i-3,4*i-4)=Cper1(4*i-3,4*i-4)-0.5+alpha_1;
    Cper1(4*i-3,4*i-3)=Cper1(4*i-3,4*i-3)+0.5+alpha_1;
    
    Cper1(4*i,4*i)=Cper1(4*i,4*i)-0.5+alpha_1; 
    Cper1(4*i,4*i+1)=Cper1(4*i,4*i+1)+0.5+alpha_1;
  end
  i=n-1;
  Cper1(4*i-3,4*i-3)=Cper1(4*i-3,4*i-3)+0.5+alpha_1;
  Cper1(4*i-3,4*i-4)=Cper1(4*i-3,4*i-4)-0.5+alpha_1;
  
  %periodique
  Cper1(4*i,4*i)=Cper1(4*i,4*i)-0.5+alpha_1;
  Cper1(4*i,1)=Cper1(4*i,1)+0.5+alpha_1;
  %endperiodic  
  
  
    alpha_2=0.02
    Cper2=C;
  %=> premier saut phiIphiJ
  %------------------------
  i=1;
  %periodique
  Cper2(1,1)=Cper2(1,1)+0.5+alpha_2;
  Cper2(1,4*n-4)=Cper2(1,4*n-4)-0.5+alpha_2;
  %endperiodic
  
  Cper2(4,4)=Cper2(4,4)-0.5+alpha_2;
  Cper2(4,5)=Cper2(4,5)+0.5+alpha_2;
  for i=2:n-2
    Cper2(4*i-3,4*i-4)=Cper2(4*i-3,4*i-4)-0.5+alpha_2;
    Cper2(4*i-3,4*i-3)=Cper2(4*i-3,4*i-3)+0.5+alpha_2;
    
    Cper2(4*i,4*i)=Cper2(4*i,4*i)-0.5+alpha_2; 
    Cper2(4*i,4*i+1)=Cper2(4*i,4*i+1)+0.5+alpha_2;
  end
  i=n-1;
  Cper2(4*i-3,4*i-3)=Cper2(4*i-3,4*i-3)+0.5+alpha_2;
  Cper2(4*i-3,4*i-4)=Cper2(4*i-3,4*i-4)-0.5+alpha_2;
  
  %periodique
  Cper2(4*i,4*i)=Cper2(4*i,4*i)-0.5+alpha_2;
  Cper2(4*i,1)=Cper2(4*i,1)+0.5+alpha_2;
  %endperiodic  
  
  %--------------------
  % Fin cond Periodique
 ...
 %---------------------------------------------------------------------------------
 
 
  %---------------------------------------------------------------------------------
  % Condition Dirichlet
  %----------------------
  alpha=1
  Cdir1=C;
  %=> premier saut phiIphiJ
  %------------------------
  i=1;
  %periodique
  Cdir1(1,1)=Cdir1(1,1)+alpha;
  Cdir1(1,4*n-4)=Cdir1(1,4*n-4);
  %endperiodic
  
  Cdir1(4,4)=Cdir1(4,4)-0.5;
  Cdir1(4,5)=Cdir1(4,5)+0.5;
  for i=2:n-2
    Cdir1(4*i-3,4*i-4)=Cdir1(4*i-3,4*i-4)-0.5;
    Cdir1(4*i-3,4*i-3)=Cdir1(4*i-3,4*i-3)+0.5;
    
    Cdir1(4*i,4*i)=Cdir1(4*i,4*i)-0.5; 
    Cdir1(4*i,4*i+1)=Cdir1(4*i,4*i+1)+0.5;
  end
  i=n-1;
  Cdir1(4*i-3,4*i-3)=Cdir1(4*i-3,4*i-3)+0.5;
  Cdir1(4*i-3,4*i-4)=Cdir1(4*i-3,4*i-4)-0.5;
  
  %periodique
  Cdir1(4*i,4*i)=Cdir1(4*i,4*i)-alpha;
  Cdir1(4*i,1)=Cdir1(4*i,1);
  %endperiodic  
  
    %---------------------------------------------------------------------------------
  % Condition Dirichlet
  %----------------------
  alpha=0
  Cdir2=C;
  %=> premier saut phiIphiJ
  %------------------------
  i=1;
  %periodique
  Cdir2(1,1)=Cdir2(1,1)+alpha;
  Cdir2(1,4*n-4)=Cdir2(1,4*n-4);
  %endperiodic
  
  Cdir2(4,4)=Cdir2(4,4)-0.5;
  Cdir2(4,5)=Cdir2(4,5)+0.5;
  for i=2:n-2
    Cdir2(4*i-3,4*i-4)=Cdir2(4*i-3,4*i-4)-0.5;
    Cdir2(4*i-3,4*i-3)=Cdir2(4*i-3,4*i-3)+0.5;
    
    Cdir2(4*i,4*i)=Cdir2(4*i,4*i)-0.5; 
    Cdir2(4*i,4*i+1)=Cdir2(4*i,4*i+1)+0.5;
  end
  i=n-1;
  Cdir2(4*i-3,4*i-3)=Cdir2(4*i-3,4*i-3)+0.5;
  Cdir2(4*i-3,4*i-4)=Cdir2(4*i-3,4*i-4)-0.5;
  
  %periodique
  Cdir2(4*i,4*i)=Cdir2(4*i,4*i)-alpha;
  Cdir2(4*i,1)=Cdir2(4*i,1);
  %endperiodic  
  
  %--------------------
  % Fin cond Dirichlet
  %---------------------------------------------------------------------------------
  
  %%================================
  %%% Calcul de la matrice A=M^(-1)C
  %%================================
  if (FC==1)
    Av=Minv*Cper1';
    Ap=Minv*Cper2';
  elseif (FC==0)
      Av=Minv*Cper';
      Ap=-Minv*Cper;
  end
  %%=================================
  %%%
  %%% Calcul de la condition initiale
  %%%
  %%=================================
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %Pour la derivee seconde de gaussienne
  %Solution analytique 
  %Sol(x,t)=(x-x0-t)exp(-(2*pi*(x-x0-t)/r0).^2)
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  for i=1:4*(n-1)
    if abs(X(i)-x0)<=le/2 
      R(i)=X(i)-x0;
    else
      R(i)=X(i)-x0-le;
    end
  end
  
  Vold0=(R.*exp(-(2*pi*R/r0).^2))';
  Polddm=((R-(0.5*dt)).*exp(-(2*pi*(R-(0.5*dt))/r0).^2))';
  
  plot(X,Vold0)
  set(gca,'Fontsize',16)
  
  %  return
  j=0;
  N=ceil(T/dt); %nb pas de temps 
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%
  %%% La boucle en temps
  %%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  %------
  %Erreur
  Erreur1=0;
  Erreur(1)=0;
  j=0;
  
  
  for t=0:dt:T+14*dt
    %------
    %Erreur
    j=j+1;
    Erreur2(j)=0;
    xx(1)=6.0037409897572858D-3;
    xx(2)=3.1363303799647048D-2;
    xx(3)=7.5896708294786392D-2;
    xx(4)=1.3779113431991498D-1;
    xx(5)=2.1451391369573058D-1;
    xx(6)=3.0292432646121832D-1;
    xx(7)=3.9940295300128274D-1;
    xx(8)=5.D-1;
    xx(9)=1-xx(7);
    xx(10)=1-xx(6);
    xx(11)=1-xx(5);
    xx(12)=1-xx(4);
    xx(13)=1-xx(3);
    xx(14)=1-xx(2);
    xx(15)=1-xx(1);
    
    for k=1:n-1
	for l=1:15
	  m(l)=Vold0(4*(k-1)+1)*Phi1(xx(l))+Vold0(4*(k-1)+2)*Phi2(xx(l))...
	       +Vold0(4*(k-1)+3)*Phi3(xx(l))+Vold0(4*(k-1)+4)*Phi4(xx(l));
	end   
	xxx=x(k)+xx*h(k);
	
	for l=1:15
	  if abs(xxx(l)-x0)<=le/2 
	    rr(l)=xxx(l)-x0;
	  elseif abs(xxx(l)-x0-le)<=le/2 
	    rr(l)=xxx(l)-x0-le;
	  else
	    rr(l)=xxx(l)+le-x0;
	  end
	end  	
	e1=(rr.*exp(-(2*pi*rr/r0).^2)-m).^2;  
	
	%disp('Gauss') 
	Erreur2(j)=Erreur2(j)+Intgauss(e1)*h(k);
    end
	
    %%=================================
    %  Le schema en temps
    %%=================================
    %-------------------
    %Monitoring du temps
    %-------------------
    t
    
    %-----------------------------------------------------
    %Schema FTDSSI=(First Time Discretization Second Space
    %Integration) considéré global
    %-----------------------------------------------------
    Vold0=Vold0+dt*Av*Polddm;
    Polddm=Polddm+dt*Ap*Vold0;
    
    %----------
    %Gaussienne
    %----------
    if x0+dt <=le 
	  x0=x0+dt;
    else
      x0=x0+dt-le;
    end
    
    if (mod(j,raff)==0)
      for i=1:4*(n-1)
	if abs(X(i)-x0)<=le/2 
	  R(i)=X(i)-x0;
	elseif abs(X(i)-x0-le)<=le/2 
	  R(i)=X(i)-x0-le;
	else
	  R(i)=X(i)+le-x0;
	end
      end
      
      %----------
      % Figures
      %-----------
      
      plot(X,Polddm);
      hold on
      axis([x(1) x(end) -0.28 0.280])
      pause(0.01)
      clf
    end
  end
  disp('Simulation finie ... Calcul de l erreur : ');
  
  aa=length(Erreur2);
  bb=length(0:dt:T+14*dt);
  j=0;
  t=0;
  
  
  for i=1:14:aa
    if i+14<=aa
      j=j+1;
      Erreur1(j)=Intgauss(Erreur2(i:i+14))*14*dt;
      Erreur(j)=sqrt(sum(Erreur1));
      t=t+14*dt;
    end
  end
  t0=t-3*14*dt;
  tt=(T-t0)/(3*14*dt);
  
  Err=Erreur(end-3)*Phi1(tt)+Erreur(end-2)*Phi2(tt)...
      +Erreur(end-1)*Phi3(tt)+Erreur(end)*Phi4(tt);

